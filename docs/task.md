# 임베디드 포트폴리오 프로젝트 Task List

## 📋 프로젝트 개요
산업용 실시간 제어 시스템 개발을 통한 임베디드 개발자 핵심 역량 증명

---

## 🎯 Phase 1: 프로젝트 설정 및 환경 구축

### 1.1 개발 환경 설정
- [ ] STM32CubeIDE 설치 및 설정
- [ ] Git 저장소 초기화 및 `.gitignore` 설정
- [ ] 하드웨어 선택 (STM32 또는 ESP32)
- [ ] 개발 보드 준비 및 연결 테스트
- [ ] Logic Analyzer 설정 (신호 분석용)

### 1.2 프로젝트 구조 설계
- [ ] 디렉토리 구조 설계
  - [ ] `/src` - 소스 코드
  - [ ] `/inc` - 헤더 파일
  - [ ] `/test` - 테스트 코드
  - [ ] `/docs` - 문서
  - [ ] `/hardware` - 회로도 및 하드웨어 문서
- [ ] 빌드 시스템 설정 (Makefile 또는 CMake)
- [ ] 코딩 컨벤션 문서 작성

### 1.3 테스트 프레임워크 설정
- [ ] Unity 테스트 프레임워크 설치
- [ ] Ceedling 설정 (선택사항)
- [ ] 테스트 자동화 스크립트 작성
- [ ] CI/CD 파이프라인 기본 설정 (GitHub Actions)

---

## 🔧 Phase 2: FreeRTOS 기반 멀티태스킹 구현

### 2.1 FreeRTOS 통합
- [ ] FreeRTOS 소스 코드 추가
- [ ] `FreeRTOSConfig.h` 설정
  - [ ] Heap 크기 설정
  - [ ] Tick rate 설정 (1ms 권장)
  - [ ] 우선순위 레벨 정의
- [ ] 기본 태스크 생성 및 실행 테스트

### 2.2 센서 데이터 수집 태스크
- [ ] 센서 인터페이스 정의 (ADC, I2C 등)
- [ ] 센서 드라이버 구현
  - [ ] 초기화 함수
  - [ ] 데이터 읽기 함수
  - [ ] 에러 핸들링
- [ ] 데이터 수집 태스크 구현
  - [ ] 주기적 샘플링 (100ms 간격)
  - [ ] 데이터 필터링 (이동 평균 등)
  - [ ] Queue를 통한 데이터 전달
- [ ] 단위 테스트 작성

### 2.3 통신 처리 태스크
- [ ] 통신 프로토콜 선택 및 설계
- [ ] 송신 버퍼 관리
- [ ] 수신 버퍼 관리
- [ ] 통신 태스크 구현
  - [ ] Queue에서 데이터 수신
  - [ ] 프로토콜 패킷 생성
  - [ ] 데이터 전송
- [ ] 단위 테스트 작성

### 2.4 시스템 모니터링 태스크 (Watchdog)
- [ ] Watchdog 타이머 설정
- [ ] 시스템 상태 모니터링 로직
  - [ ] CPU 사용률 측정
  - [ ] 메모리 사용량 체크
  - [ ] 태스크 상태 확인
- [ ] 이상 감지 시 복구 로직
- [ ] 로그 기록 기능
- [ ] 단위 테스트 작성

### 2.5 태스크 간 동기화
- [ ] Semaphore 구현
  - [ ] Binary Semaphore (리소스 보호)
  - [ ] Counting Semaphore (이벤트 카운팅)
- [ ] Queue 구현
  - [ ] 센서 데이터 Queue
  - [ ] 통신 데이터 Queue
- [ ] Mutex 구현 (공유 리소스 보호)
- [ ] 우선순위 역전 방지 설정
- [ ] 통합 테스트 작성

---

## 📡 Phase 3: CAN Bus 통신 구현

### 3.1 CAN Bus 하드웨어 설정
- [ ] CAN 트랜시버 연결 (예: MCP2551)
- [ ] CAN 핀 설정 (TX, RX)
- [ ] CAN 버스 종단 저항 확인
- [ ] 하드웨어 연결 테스트

### 3.2 CAN 드라이버 구현
- [ ] CAN 초기화 함수
  - [ ] Baud rate 설정 (500kbps 권장)
  - [ ] 필터 설정
  - [ ] 인터럽트 설정
- [ ] CAN 송신 함수
  - [ ] 메시지 큐잉
  - [ ] 전송 완료 확인
- [ ] CAN 수신 함수
  - [ ] 인터럽트 핸들러
  - [ ] 메시지 파싱
- [ ] 에러 핸들링
  - [ ] Bus-off 복구
  - [ ] 에러 카운터 모니터링

### 3.3 CAN 프로토콜 구현
- [ ] 메시지 ID 정의
- [ ] 데이터 프레임 구조 설계
- [ ] 필터링 로직 구현
  - [ ] ID 기반 필터
  - [ ] Mask 설정
- [ ] 브로드캐스트 메시지 처리
- [ ] 단위 테스트 작성

### 3.4 CAN 통합 테스트
- [ ] 노드 간 통신 테스트
- [ ] 고부하 상황 테스트
- [ ] 에러 복구 시나리오 테스트
- [ ] Logic Analyzer로 신호 검증

---

## 🔌 Phase 4: Modbus RTU 프로토콜 구현

### 4.1 UART 설정
- [ ] UART 핀 설정 (TX, RX, DE/RE)
- [ ] Baud rate 설정 (9600 또는 115200)
- [ ] 패리티 및 정지 비트 설정
- [ ] DMA 설정 (선택사항)

### 4.2 Modbus RTU 프로토콜 스택
- [ ] Modbus 프레임 구조 정의
  - [ ] 슬레이브 주소
  - [ ] 펑션 코드
  - [ ] 데이터 필드
  - [ ] CRC-16 체크섬
- [ ] CRC-16 계산 함수 구현
- [ ] 프레임 파싱 함수
- [ ] 프레임 생성 함수

### 4.3 Modbus 펑션 코드 구현
- [ ] 0x03: Read Holding Registers
- [ ] 0x04: Read Input Registers
- [ ] 0x06: Write Single Register
- [ ] 0x10: Write Multiple Registers
- [ ] 에러 응답 처리
- [ ] 단위 테스트 작성

### 4.4 Modbus 마스터/슬레이브 구현
- [ ] 슬레이브 모드 구현
  - [ ] 요청 수신 및 파싱
  - [ ] 레지스터 맵 관리
  - [ ] 응답 생성 및 전송
- [ ] 마스터 모드 구현 (선택사항)
  - [ ] 요청 생성 및 전송
  - [ ] 응답 대기 및 타임아웃 처리
- [ ] 통합 테스트

### 4.5 Modbus TCP 구현 (선택사항)
- [ ] TCP/IP 스택 통합 (lwIP)
- [ ] Modbus TCP 프레임 구조
- [ ] 소켓 통신 구현
- [ ] 테스트

---

## 🛡️ Phase 5: 에러 핸들링 및 결함 허용

### 5.1 통신 에러 처리
- [ ] 타임아웃 메커니즘
  - [ ] 송신 타임아웃
  - [ ] 수신 타임아웃
- [ ] Retry 로직 구현
  - [ ] 재시도 횟수 제한
  - [ ] 지수 백오프 (Exponential Backoff)
- [ ] 에러 로깅
- [ ] 단위 테스트

### 5.2 센서 오작동 감지
- [ ] 센서 데이터 유효성 검증
  - [ ] 범위 체크
  - [ ] 변화율 체크
- [ ] 센서 고장 감지 알고리즘
- [ ] Fallback 메커니즘
  - [ ] 기본값 사용
  - [ ] 다른 센서로 전환
- [ ] 테스트 시나리오 작성

### 5.3 HardFault 핸들러
- [ ] HardFault 핸들러 커스텀 구현
- [ ] 스택 트레이스 저장
- [ ] 레지스터 덤프
- [ ] 에러 원인 분석 로직
- [ ] 시스템 리셋 또는 안전 모드 진입
- [ ] 테스트 (의도적 오류 발생)

### 5.4 Watchdog 타이머
- [ ] Independent Watchdog (IWDG) 설정
- [ ] Window Watchdog (WWDG) 설정 (선택사항)
- [ ] 주기적 리프레시 로직
- [ ] Watchdog 리셋 감지 및 로깅
- [ ] 테스트

---

## ⚡ Phase 6: 저전력 모드 최적화

### 6.1 전력 모드 분석
- [ ] 현재 소비 전력 측정
- [ ] 각 모드별 전력 소비 분석
  - [ ] Run Mode
  - [ ] Sleep Mode
  - [ ] Stop Mode
  - [ ] Standby Mode

### 6.2 Sleep Mode 구현
- [ ] 유휴 상태 감지 로직
- [ ] Sleep Mode 진입 함수
- [ ] 웨이크업 소스 설정
  - [ ] 인터럽트 기반 웨이크업
  - [ ] 타이머 기반 웨이크업
- [ ] 전력 소비 측정 및 비교

### 6.3 주변장치 전력 관리
- [ ] 사용하지 않는 클록 비활성화
- [ ] GPIO 핀 최적화 (Pull-up/down)
- [ ] 주변장치 선택적 활성화
- [ ] DMA를 통한 CPU 부하 감소

### 6.4 전력 최적화 검증
- [ ] 배터리 수명 계산
- [ ] 장시간 동작 테스트
- [ ] 전력 프로파일링
- [ ] 최적화 전후 비교 문서화

---

## 🧪 Phase 7: 테스트 및 검증

### 7.1 Unit Testing
- [ ] 각 모듈별 단위 테스트 작성
  - [ ] 센서 드라이버
  - [ ] 통신 프로토콜
  - [ ] 에러 핸들링
  - [ ] 전력 관리
- [ ] 코드 커버리지 80% 이상 달성
- [ ] 테스트 자동화

### 7.2 통합 테스트
- [ ] 태스크 간 통신 테스트
- [ ] 전체 시스템 동작 테스트
- [ ] 부하 테스트
  - [ ] 최대 데이터 처리량
  - [ ] 동시 다발적 이벤트
- [ ] 스트레스 테스트

### 7.3 Hardware-in-the-Loop (HIL) 테스트
- [ ] HIL 테스트 환경 구축
  - [ ] 신호 발생기 설정
  - [ ] 가상 센서 데이터 생성
- [ ] 테스트 시나리오 작성
  - [ ] 정상 동작 시나리오
  - [ ] 에러 상황 시나리오
  - [ ] 엣지 케이스
- [ ] 테스트 실행 및 결과 문서화

### 7.4 성능 측정
- [ ] 태스크 응답 시간 측정 (< 10ms 목표)
- [ ] 통신 성공률 측정 (> 99.9% 목표)
- [ ] 전력 소비 감소율 측정 (> 30% 목표)
- [ ] MTBF 측정 (> 1000시간 목표)
- [ ] 성과 지표 문서화

---

## 📚 Phase 8: 문서화

### 8.1 기술 문서
- [ ] 시스템 아키텍처 문서
  - [ ] 블록 다이어그램
  - [ ] 태스크 다이어그램
  - [ ] 통신 프로토콜 다이어그램
- [ ] API 문서 (Doxygen)
- [ ] 설정 가이드
- [ ] 트러블슈팅 가이드

### 8.2 테스트 문서
- [ ] 테스트 계획서
- [ ] 테스트 케이스 문서
- [ ] 테스트 결과 보고서
- [ ] HIL 테스트 시나리오 문서

### 8.3 사용자 문서
- [ ] README.md 작성
  - [ ] 프로젝트 소개
  - [ ] 빌드 방법
  - [ ] 실행 방법
  - [ ] 기여 가이드
- [ ] 설치 가이드
- [ ] 하드웨어 연결 가이드

### 8.4 포트폴리오 문서
- [x] PRD.md (Product Requirements Document)
- [x] presentation.md (프레젠테이션)
- [x] task.md (작업 목록)
- [ ] 프로젝트 회고록
  - [ ] 배운 점
  - [ ] 어려웠던 점
  - [ ] 개선 사항

---

## 🎨 Phase 9: 시각화 및 데모

### 9.1 데모 준비
- [ ] 데모 시나리오 작성
- [ ] 데모 영상 촬영
  - [ ] 시스템 부팅
  - [ ] 센서 데이터 수집
  - [ ] 통신 동작
  - [ ] 에러 복구
- [ ] 스크린샷 및 다이어그램 준비

### 9.2 시각화 도구
- [ ] 실시간 데이터 모니터링 도구
  - [ ] UART 터미널
  - [ ] CAN 분석기
  - [ ] Logic Analyzer 캡처
- [ ] 그래프 및 차트 생성
- [ ] 성능 대시보드

### 9.3 GitHub 저장소 정리
- [ ] 코드 정리 및 리팩토링
- [ ] 주석 추가 및 개선
- [ ] 불필요한 파일 제거
- [ ] 릴리스 노트 작성
- [ ] 태그 및 버전 관리

---

## 🚀 Phase 10: 확장 기능 (선택사항)

### 10.1 무선 통신
- [ ] Wi-Fi 모듈 통합 (ESP32)
- [ ] Bluetooth 통신 구현
- [ ] 원격 모니터링 웹 인터페이스
- [ ] OTA (Over-The-Air) 펌웨어 업데이트

### 10.2 보안 기능
- [ ] 통신 암호화 (AES)
- [ ] 인증 메커니즘
- [ ] Secure Boot
- [ ] 펌웨어 서명 검증

### 10.3 데이터 로깅
- [ ] SD 카드 인터페이스
- [ ] Flash 메모리 활용
- [ ] 데이터 압축
- [ ] 로그 파일 관리

### 10.4 IoT 연동
- [ ] MQTT 프로토콜 구현
- [ ] 클라우드 플랫폼 연동 (AWS IoT, Azure IoT)
- [ ] 데이터 시각화 대시보드
- [ ] 알림 시스템

### 10.5 엣지 AI
- [ ] TensorFlow Lite Micro 통합
- [ ] 센서 데이터 기반 예측 모델
- [ ] 이상 탐지 알고리즘
- [ ] 예측 유지보수 기능

---

## 📊 진행 상황 요약

### 전체 진행률
- Phase 1: [ ] 0/13 (0%)
- Phase 2: [ ] 0/23 (0%)
- Phase 3: [ ] 0/15 (0%)
- Phase 4: [ ] 0/16 (0%)
- Phase 5: [ ] 0/15 (0%)
- Phase 6: [ ] 0/12 (0%)
- Phase 7: [ ] 0/14 (0%)
- Phase 8: [ ] 3/15 (20%)
- Phase 9: [ ] 0/11 (0%)
- Phase 10: [ ] 0/17 (0%)

**전체: 3/151 (2%)**

---

## 🎯 우선순위

### High Priority (필수)
- Phase 1: 프로젝트 설정
- Phase 2: FreeRTOS 멀티태스킹
- Phase 3: CAN Bus 통신
- Phase 5: 에러 핸들링
- Phase 7: 테스트 및 검증
- Phase 8: 문서화

### Medium Priority (권장)
- Phase 4: Modbus RTU
- Phase 6: 저전력 최적화
- Phase 9: 시각화 및 데모

### Low Priority (선택사항)
- Phase 10: 확장 기능

---

## 📅 예상 일정

| Phase | 예상 소요 시간 | 비고 |
|-------|---------------|------|
| Phase 1 | 1-2일 | 환경 설정 |
| Phase 2 | 5-7일 | 핵심 기능 |
| Phase 3 | 3-4일 | CAN Bus |
| Phase 4 | 3-4일 | Modbus |
| Phase 5 | 2-3일 | 에러 처리 |
| Phase 6 | 2-3일 | 전력 최적화 |
| Phase 7 | 4-5일 | 테스트 |
| Phase 8 | 2-3일 | 문서화 |
| Phase 9 | 1-2일 | 데모 준비 |
| **총계** | **23-33일** | **약 1개월** |

---

## 💡 Tips

- 각 Phase를 완료할 때마다 Git commit 수행
- 테스트 코드를 먼저 작성하는 TDD 방식 권장
- 주기적으로 코드 리뷰 및 리팩토링
- 문제 발생 시 즉시 문서화
- Logic Analyzer를 적극 활용하여 신호 검증

---

## 📝 Notes

- 이 task.md는 프로젝트 진행에 따라 지속적으로 업데이트됩니다
- 체크박스를 활용하여 진행 상황을 추적하세요
- 각 태스크 완료 시 관련 문서 및 테스트 결과를 함께 기록하세요
